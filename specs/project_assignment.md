# Задание

Разработать библиотеку (crate) для парсинга/сериализации/десериализации финансовых данных в несколько форматов и отдельный исполняемый cli (консольное приложение) crate, использующий данную библиотеку.

## Поддерживаемые форматы (минимум для реализации)

- CSV/XML (обычные произвольные банковские/бухгалтерские выгрузки)
- MT940 (SWIFT-подобные выписки)
- CAMT.053 (ISO 20022)

**Примеры форматов приложены в виде файлов в папке examples**

---

## Детали задания

### Необходимо реализовать три крейта

#### Крейт Parser

Библиотека, обеспечивающая парсинг и сериализацию форматов.

Реализации парсера должны использовать абстракции, предоставляемые стандартной библиотекой языка, чтобы обеспечить гибкость кода. Не следует жестко привязывать реализацию парсера к конкретному типу источника данных.

Чтобы это сделать, используйте стандартные трейты ввода/вывода (в первую очередь `Read` для чтения и `Write` для записи), а не пишите отдельные реализаций для каждого источника (файла, stdin, массива байт и т.д.). Трейты `Read` и `Write` уже реализованы для множества типов — можно почитать про это в документации Rust.

**Пример:**

```rust
struct YPBankBinRecord {
    // Поля структуры, представляющей содержимое записи
}

impl YPBankBinRecord {
    // Парсит из любого источника, реализующего трейт Read
    pub fn from_read<R: std::io::Read>(r: &mut R) -> Result<Self> {
        todo!()
    }

    // Записывает отчёт в любой приёмник, реализующий трейт Write
    pub fn write_to<W: std::io::Write>(&mut self, writer: &mut W) -> Result<()> {
        todo!()
    }
}
```

Использование трейтов позволяет избежать дублирования кода: не нужно реализовывать отдельные парсеры для файлов, stdin, буферов и т.п. Кроме того, сторонние крейты также могут предоставлять свои реализации этих трейтов.

#### CLI Converter

Консольное приложение, использующее функциональность парсеров из первого крейта.

Парсеры крейта «парсер» принимают в качестве входа типы, удовлетворяющие трейту `Read`. CLI-приложение должно читать данные из файла и выводить результат в stdout. Для библиотеки ничего не меняется — она работает с абстракциями, определёнными в стандартной библиотеке, реализованными для типа `File` и доступными в любом Rust-приложении.

За счёт статического полиморфизма (мономорфизации) в итоговый бинарник попадут только те реализации трейтов, которые реально используются.

**Пример запуска утилиты:**

```bash
ypbank_converter \
  --input <input_file> \
  --input-format <format> \
  --output-format <format> \
  > output_file.txt
```

#### CLI Comparer

Консольное приложение, использующее функциональность парсеров из lib-крейта.

CLI Comparer должен читать данные о транзакциях из двух файлов и сравнивать их. Входные файлы могут быть в любых форматах, которые поддерживаются парсерами из lib-крейта. В случае несовпадения, утилита должна сообщать какая транзакция не совпала.

**Пример запуска утилиты:**

```bash
ypbank_compare --file1 records_example.bin --format1 binary --file2 records_example.csv --format2 csv
# Output: The transaction records in 'records_example.bin' and 'records_example.csv' are identical.
```

---

## Требования к результатам работы

### Общие требования к проекту

- Данные преобразования должны производиться за счёт трейтов стандартной библиотеки.
- Реализации парсера должны использовать имеющиеся абстракции, поставляемые с языком для достижения гибкости кода. Не нужно делать реализации парсера в привязке к типу данных напрямую.
- Крейт для парсинга данных должен быть отдельным, а крейты для исполняемых файлов импортировать данный крейт.
- Не использовать `unwrap` в крейтах.
- Реализовать понятные ошибки и корректно их отработать в коде.
- Публичные элементы крейта «Парсер» должны быть покрыты документацией.
- Код должен быть покрыт тестами.

### Функциональные требования

**Крейт «парсер» должен:**

- Читать данные вышеупомянутых форматов.
- Записывать данные вышеупомянутых форматов.
- Конвертировать MT940 в CAMT.053 (ISO 20022) и наоборот. При переводе из MT940 допустимо заполнить недостающую информацию плейсхолдерами. А при переводе из CAMT.053 можно информацию, которая не помещается в MT940, поместить в поле `:86`. Конвертация должна быть реализована через трейт `From` для структур, представляющих распарсенные MT940 и CAMT.053. Это позволит легко конвертировать данные между форматами на уровне типов.
- Возвращать понятные ошибки, если такие встречаются при парсинге.

**CLI-приложение:**

- Использует библиотеку «парсер» и предоставляет:
  - Чтение из файла или stdin.
  - Запись в файл или stdout.
  - Опции формата ввода и вывода (`--in-format` и `--out-format`).
- Реализует функции, предоставляемые крейтом парсера.

CLI выступает в роли «прокси» между пользователем и библиотекой: оно вызывает методы парсеров (например, `from_read` и `write_to`) и обеспечивает маршрутизацию ввода/вывода между файловой системой и стандартными потоками. Поскольку парсеры работают с абстракциями `Read`/`Write`, для них нет различия между источниками/приёмниками данных.

**Списки реализаций трейтов:**

- Read: https://doc.rust-lang.org/std/io/trait.Read.html#implementors
- Write: https://doc.rust-lang.org/std/io/trait.Write.html#implementors

---

## Подсказки

### Как выполнить проектную работу

1. Создать новый многомодульный проект в склонированной папке. Проект должен быть публичным, чтобы ревьюер мог с ним работать.
2. Написать `README.md` файл в корне репозитория и папках с самими крейтами.
3. Создать папку `examples` с примерами использования крейта «парсер» для Опции 1. А для опции 2 создать папку `src/bin` для CLI приложений, использующих крейт «парсер».
4. Написать модульные тесты для крейта «парсер».
5. В коммитах документировать внесённые изменения.

### Пример организации проекта

```
Cargo.toml
src/
├── lib.rs — общие типы и логика для преобразования форматов
├── error.rs — описание ошибок
├── main.rs — приложение для конвертации файлов
├── bin_format.rs — логика и типы для двоичного формата
├── txt_format.rs — логика и типы для текстового формата
├── csv_format.rs — логика и типы для csv формата
└── bin/
    └── comparer.rs — приложение для сравнения файлов
```

### Что нужно проверить

- Правильность оформления крейтов в `Cargo.toml`.
- Структуру крейтов по модулям — в том числе наличие файлов `error.rs` или `result.rs` для ошибок.
- Именование модулей, функций, методов, структур и трейтов согласно их назначению.
- Отсутствие отдельных реализаций функциональностей там, где этого можно избежать применением трейтов `Read` и `BufRead` для чтения и `Write` для записи соответственно.
- Структуру проекта — каждая библиотека должна отвечать за свою отдельную функциональность. В нашем случае это чтение, перевод и запись файлов.
- Версионирование — если есть breaking changes, то это должно отражаться в обновлении версии библиотеки.
- Видимость: `pub crate`/`pub super`/`pub`.
- Покрытие тестами.
- Отсутствие жёсткой привязки версий зависимостей — например, использование `serde = "1.0.219"` вместо `1`.
- Понятные ошибки.
- Отсутствие злоупотребления клонированием.

---
